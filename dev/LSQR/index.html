<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving photoacoustic least squares with IterativeSolvers.jl · Photoacoustic imaging in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Photoacoustic imaging in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../derivations/">Theory</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Solving photoacoustic least squares with IterativeSolvers.jl</a><ul class="internal"><li><a class="tocitem" href="#Define-photoacoustic-simulation"><span>Define photoacoustic simulation</span></a></li><li><a class="tocitem" href="#Make-observed-data"><span>Make observed data</span></a></li><li><a class="tocitem" href="#Iteratively-solve-using-different-algorithms:"><span>Iteratively solve using different algorithms:</span></a></li><li><a class="tocitem" href="#Plotting-convergence-history"><span>Plotting convergence history</span></a></li><li><a class="tocitem" href="#Plotting-results"><span>Plotting results</span></a></li></ul></li><li><a class="tocitem" href="../LearnedPrior/">Integrating Photoacoustic operations with automatic differention in Flux.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Solving photoacoustic least squares with IterativeSolvers.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving photoacoustic least squares with IterativeSolvers.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/PhotoAcoustic.jl/blob/master/docs/src/LSQR.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-photoacoustic-least-squares-with-IterativeSolvers.jl"><a class="docs-heading-anchor" href="#Solving-photoacoustic-least-squares-with-IterativeSolvers.jl">Solving photoacoustic least squares with IterativeSolvers.jl</a><a id="Solving-photoacoustic-least-squares-with-IterativeSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-photoacoustic-least-squares-with-IterativeSolvers.jl" title="Permalink"></a></h1><p>In this tutorial, we will illustrate how to use Photoacoustic.jl in tandem with the solvers in IterativeSolvers.jl to solve inverse problems. Our illustration will be a photoacoustic inverse problem where the observe data has been generated by a photoacoustic operator plus corrupting noise: <span>$y = Ax^{\star} + \varepsilon$</span> where we assume the noise comes from a standard Normal distribution. We want to solve this inverse problem in the least squares sense: <span>$\hat x = \mathrm{argmin}_{x} \, \|Ax - y\|_2^2$</span></p><p>To use the solvers in IterativeSolver.jl all we need is to define matrix vector products <span>$Av$</span> and adjoint matrix vector products <span>$A^{\top}v$</span>. These are both implemented in PhotoAcoustic.jl.</p><pre><code class="language-julia">using PhotoAcoustic
using JUDI
using PyPlot
using LinearAlgebra</code></pre><pre><code class="language-none">┌ Info: Precompiling PhotoAcoustic [86b14aa7-fcb7-4836-b4c7-056f45a9c77b]
└ @ Base loading.jl:1423</code></pre><h2 id="Define-photoacoustic-simulation"><a class="docs-heading-anchor" href="#Define-photoacoustic-simulation">Define photoacoustic simulation</a><a id="Define-photoacoustic-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Define-photoacoustic-simulation" title="Permalink"></a></h2><pre><code class="language-julia"># Set up model structure
n = (128, 128)   # (x,y,z) or (x,z)
d = (0.08f0, 0.08f0)
o = (0., 0.)

# Constant water velocity [mm/microsec]
v = 1.5*ones(Float32,n) 
m = (1f0 ./ v).^2 # JUDI is parameterized by slowness

# Setup model structure
model = Model(n, d, o, m;)

# Set up receiver geometry (receivers on top of model)
nxrec = 32
xrec = range(0, stop=d[1]*(n[1]-1), length=nxrec)
yrec = [0f0]
zrec = range(0, stop=0, length=nxrec)

# receiver sampling and recording time
time = 10 #[microsec] 
dt = calculate_dt(model) / 2    

# Set up receiver structure
recGeometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=1)

# Setup operators
opt = Options(dt_comp=dt)
F = judiModeling(model; options=opt)
A = judiPhoto(F, recGeometry;)</code></pre><pre><code class="language-none">JUDI forward{Float32} propagator (z * x) -&gt; (src * rec * time)</code></pre><h2 id="Make-observed-data"><a class="docs-heading-anchor" href="#Make-observed-data">Make observed data</a><a id="Make-observed-data-1"></a><a class="docs-heading-anchor-permalink" href="#Make-observed-data" title="Permalink"></a></h2><p>We make observed data by running the linear photoacoustic simulation represented by <span>$A$</span> and then adding gaussian noise to the data. </p><pre><code class="language-julia">using JLD2
file_vessels = load(&quot;$(PhotoAcoustic.PhotoAcoustic_data)/vessels_2d.jld&quot;)
vessels = file_vessels[&quot;vessels&quot;]
x = judiInitialState(vessels)</code></pre><p>As ground truth we use a realistic model of a blood vessel derived from lung ct scans. </p><pre><code class="language-julia"># Run forward model and add noise
y = A*x 
y = y + judiVector(recGeometry, 0.05f0*randn(Float32, size(y.data[1])))

data_extent = (0, nxrec, time,0)
model_extent = (0,(n[1]-1)*d[1],(n[2]-1)*d[2],0)

subplot(1,2,1); title(L&quot;Ground truth $x$&quot;)
imshow(x.data[1]&#39;;extent=model_extent);
xlabel(&quot;Vertical Position [mm]&quot;);ylabel(&quot;Lateral Position [mm]&quot;);
PyPlot.scatter(xrec, zrec;color=&quot;red&quot;,label=&quot;Receivers&quot;)
legend(loc=&quot;lower left&quot;)

subplot(1,2,2); title(L&quot;Observed data $y=Ax+\epsilon$&quot;)
imshow(y.data[1]; cmap=&quot;seismic&quot;, extent=data_extent, aspect=10,vmax=0.2,vmin=-0.2)
xlabel(&quot;Receiver index&quot;);ylabel(&quot;Time [microseconds]&quot;);


tight_layout()</code></pre><pre><code class="language-none">Operator `forward` ran in 0.47 s</code></pre><p><img src="../LSQR_files/LSQR_7_1.png" alt="png"/></p><h2 id="Iteratively-solve-using-different-algorithms:"><a class="docs-heading-anchor" href="#Iteratively-solve-using-different-algorithms:">Iteratively solve using different algorithms:</a><a id="Iteratively-solve-using-different-algorithms:-1"></a><a class="docs-heading-anchor-permalink" href="#Iteratively-solve-using-different-algorithms:" title="Permalink"></a></h2><pre><code class="language-julia">using IterativeSolvers

x_adj = A&#39;*y
x_lsqr = 0f0 .* x

maxiters = 20
_, history_lsqr = lsqr!(x_lsqr, A, y; maxiter=maxiters, verbose=true, log=true)</code></pre><pre><code class="language-none">=== lsqr ===
iter	resnorm		  anorm		  cnorm		  rnorm
  1	1.27e+00	8.01e-01	2.86e+00	7.71e-01
  2	1.11e+00	3.54e-01	1.02e+00	6.78e-01
  3	9.99e-01	2.07e-01	6.01e-01	6.09e-01
  4	9.35e-01	1.20e-01	4.36e-01	5.70e-01
  5	8.93e-01	8.66e-02	3.48e-01	5.44e-01
  6	8.69e-01	6.32e-02	2.89e-01	5.30e-01
  7	8.50e-01	5.03e-02	2.46e-01	5.18e-01
  8	8.38e-01	3.87e-02	2.14e-01	5.11e-01
  9	8.31e-01	2.55e-02	1.90e-01	5.06e-01
 10	8.28e-01	2.01e-02	1.70e-01	5.04e-01
 11	8.26e-01	1.20e-02	1.54e-01	5.03e-01
 12	8.25e-01	8.24e-03	1.41e-01	5.03e-01
 13	8.24e-01	6.49e-03	1.31e-01	5.02e-01
 14	8.24e-01	5.59e-03	1.21e-01	5.02e-01
 15	8.23e-01	5.33e-03	1.12e-01	5.02e-01
 16	8.23e-01	5.73e-03	1.02e-01	5.02e-01
 17	8.22e-01	5.69e-03	9.44e-02	5.01e-01
 18	8.22e-01	5.22e-03	8.75e-02	5.01e-01
 19	8.21e-01	4.36e-03	8.19e-02	5.01e-01
 20	8.21e-01	3.64e-03	7.73e-02	5.01e-01



Operator `adjoint` ran in 0.54 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.41 s
Operator `adjoint` ran in 0.42 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.61 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.56 s
Operator `adjoint` ran in 0.49 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.53 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.44 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.41 s
Operator `adjoint` ran in 0.42 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.42 s
Operator `adjoint` ran in 0.48 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.40 s
Operator `adjoint` ran in 0.42 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.46 s
Operator `adjoint` ran in 1.44 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 1.18 s
Operator `adjoint` ran in 0.68 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.42 s
Operator `adjoint` ran in 0.44 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.41 s
Operator `adjoint` ran in 0.45 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.46 s
Operator `adjoint` ran in 0.60 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.46 s
Operator `adjoint` ran in 0.43 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.45 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.41 s
Operator `adjoint` ran in 0.52 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.45 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.47 s
Operator `adjoint` ran in 0.42 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.73 s
Operator `adjoint` ran in 0.46 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.41 s
Operator `adjoint` ran in 0.41 s
Operator `Kernel` ran in 0.01 s
Operator `forward` ran in 0.45 s
Operator `adjoint` ran in 0.46 s
Operator `Kernel` ran in 0.01 s





(judiInitialState{Float32} with 1 sources, Converged after 20 iterations.)</code></pre><h2 id="Plotting-convergence-history"><a class="docs-heading-anchor" href="#Plotting-convergence-history">Plotting convergence history</a><a id="Plotting-convergence-history-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-convergence-history" title="Permalink"></a></h2><pre><code class="language-julia">plot(history_lsqr[:resnorm];label=&quot;LSQR&quot;)
ylabel(&quot;Residual norm&quot;); xlabel(&quot;Iteration&quot;); legend()</code></pre><p><img src="../LSQR_files/LSQR_11_0.png" alt="png"/></p><pre><code class="language-none">PyObject &lt;matplotlib.legend.Legend object at 0x15aa35280&gt;</code></pre><h2 id="Plotting-results"><a class="docs-heading-anchor" href="#Plotting-results">Plotting results</a><a id="Plotting-results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-results" title="Permalink"></a></h2><p>We can visualize our results and interpret that the adjoint solution can resolve the main structures but has wrong amplitudes. A least sqeares method such as LSQR will help bring amplitudes to the correct level. Also observe that both the adjoint and LSQR can resolve structures that are perpendicular to the receiver geometry but miss vertical vessels. This is because the vertical events are in the null space of the operator.  </p><pre><code class="language-julia">fig = figure(figsize=(10,7))
suptitle(&quot;Iterative solvers results with $(maxiters) iterations&quot;)

subplot(2,3,1); title(&quot;Ground truth&quot;) 
imshow(x.data[1]&#39;;extent=model_extent, vmin=0,vmax=1)
ylabel(&quot;Z Position [mm]&quot;;); xlabel(&quot;X Position [mm]&quot;; ); colorbar()
PyPlot.scatter(xrec, zrec;color=&quot;red&quot;,label=&quot;Receivers&quot;)
legend(loc=&quot;lower left&quot;)

subplot(2,3,2);  title(&quot;Adjoint solution&quot;)
imshow(x_adj.data[1]&#39;;extent=model_extent)
ylabel(&quot;Z Position [mm]&quot;;); xlabel(&quot;X Position [mm]&quot;; ); colorbar()

subplot(2,3,3); title(&quot;LSQR solution&quot;)
imshow(x_lsqr.data[1]&#39;;extent=model_extent, vmin=0,vmax=1)
ylabel(&quot;Z Position [mm]&quot;;); xlabel(&quot;X Position [mm]&quot;; ); colorbar()

subplot(2,3,5);  title(&quot;Error adjoint&quot;)
imshow(x_adj.data[1]&#39; - x.data[1]&#39;;cmap=&quot;seismic&quot;, extent=model_extent, vmin=-2, vmax=2)
ylabel(&quot;Z Position [mm]&quot;;); xlabel(&quot;X Position [mm]&quot;; ); colorbar()

subplot(2,3,6); title(&quot;Error LSQR &quot;)
imshow(x_lsqr.data[1]&#39;- x.data[1]&#39;;cmap=&quot;seismic&quot;,extent=model_extent, vmin=-2, vmax=2)
ylabel(&quot;Z Position [mm]&quot;;); xlabel(&quot;X Position [mm]&quot;; ); colorbar()

tight_layout()</code></pre><p><img src="../LSQR_files/LSQR_13_0.png" alt="png"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../derivations/">« Theory</a><a class="docs-footer-nextpage" href="../LearnedPrior/">Integrating Photoacoustic operations with automatic differention in Flux. »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 October 2022 18:10">Thursday 20 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
