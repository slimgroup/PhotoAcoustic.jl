var documenterSearchIndex = {"docs":
[{"location":"derivations/#PhotoAcoustic.jl-Adjoint-and-Jacobian-derivations.","page":"Theory","title":"PhotoAcoustic.jl Adjoint and Jacobian derivations.","text":"","category":"section"},{"location":"derivations/","page":"Theory","title":"Theory","text":"To the best of our knowledge, the literature does not contain a derivation for the adjoint of the forward photoacoustic operator using the second order wave equation and its Jacobian with respect to the speed of sound. ","category":"page"},{"location":"derivations/#Forward-model","page":"Theory","title":"Forward model","text":"","category":"section"},{"location":"derivations/","page":"Theory","title":"Theory","text":"The forward model of a photoacoustic experiment can be described by the second order wave equation with active source for space x and time t:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"frac1c(x)^2fracpartial^2partial t^2u(xt) - nabla^2 u(xt) = 0","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"where the source is instead defined in the initial state:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"beginaligned\nu(x0) = p_0 \ndot u(x0) = 0\nendaligned","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"The spatial distribution p_0 is the initial acoustic source caused by the photonic impulse and is the parameter of interest when performing inversion. ","category":"page"},{"location":"derivations/#Adjoint-model-derivation","page":"Theory","title":"Adjoint model derivation","text":"","category":"section"},{"location":"derivations/","page":"Theory","title":"Theory","text":"The derivation is based on procedure and notation from PDE-constrained optimization and the adjoint method. We start by defining our optimization problem:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"undersetp_0operatornamemin   F(up_0)    mathrmwhere   F(up_0) = int_0^Tf(ut)dt = frac12 sum_r=1^R int_0^Tleft u_r(t) - d_r(t)right_2^2dt","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"beginaligned\ntextsubject to   ddot u = mnabla^2 u\nu(0) = p_0 \ndot u(0) = 0 \nendaligned","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"Where we have set m=frac1c(x)^2 to be the slowness squared. For ease of derivation of writing the Lagrangian, we will assign functions to each of these three constraints:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"beginaligned\n h(ddot up_0t) = mnabla^2 u\ng(u(0)p_0) = u(0) - p_0 = 0 \nk(dot u(0)) = dot u(0) = 0\nendaligned","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"In order to solve the minimization problem, our goal is to obtain the sensitivity of our functional F with respect to the variable p_0:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"d_p_0F","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"We start by writing out the full Lagrangian containing our functional and constraints: [...can add more details here...]. By selecting the correct multipliers [...can add more details here...] we see that the total derivative is:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"d_p_0F = d_p_0L = int_0^Tpartial_p_0f - lambda^toppartial_p_0hdt - dot lambda(0)^toppartial_u(0)g^-1partial_p_0g + lambda(0)^toppartial _dot u(0)k^-1 partial_p_0k","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"Where the notation partial_p_0f means the Jacobian of f with respect to p_0 and cdot^-1 is the matrix inverse. Lets simplify the expression by noting the following equalities:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"beginaligned\npartial_p_0f = 0 \npartial_p_0h = 0 \npartial_u(0)g^-1 = -I \npartial_p_0g  = I \npartial_p_0k = 0\nendaligned","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"giving the total derivative:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"d_p_0F = - dot lambda(0)^top","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"where lambda is the adjoint wavefield given by the solution of:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"ddot lambda = partial_uh^toplambda  -partial_uf^top    rightarrow   \nddot lambda -mnabla^2lambda = - partial_uf^top =  sum_r=1^R int_0^T(u_r(t) - d_r(t)dt","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"Note that this is the same wave equation as the forward model but with a source term given by the residual -partial_uf^topand it is solved in reverse time (from t=T to t=0) with the \"initial\" state:","category":"page"},{"location":"derivations/","page":"Theory","title":"Theory","text":"beginaligned\n lambda(T)^top = 0 \ndot lambda(T)^top = 0\nendaligned","category":"page"},{"location":"derivations/#Jacobian-derivation","page":"Theory","title":"Jacobian derivation","text":"","category":"section"},{"location":"derivations/","page":"Theory","title":"Theory","text":"TBD","category":"page"},{"location":"LearnedPrior/#Integrating-Photoacoustic-operations-with-automatic-differention-in-Flux.","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"In this tutorial, we will illustrate how to combine the operators of Photoacoustic.jl with the AD system used in Flux.jl. Our illustration will be a photoacoustic inverse problem where the observe data has been generated by a photoacoustic operator y = Ax. We want to solve this inverse problem in the least squares sense: mathrmargmin_x  Ax - y_2^2","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"In the framework of deep prior, we parameterize the unknown x as the output of an untrained neural network G_theta(z) and optimize over its learnable parameters. ","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"mathrmargmin_theta  AG_theta(z) - y_2^2","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"Here is the key: if we want to solve this variational problem we need to \"chain\" the derivatives of the learned network (derivatives come from Zygote AD system) with the derivate of the photoacoustic operator (hand derived in Photoacoustic.jl). In this tutorial we demonstrate how this is easily done with the ChainRules.jl framework. ","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"using PhotoAcoustic\nusing JUDI\nusing Flux\nusing ProgressMeter: Progress, next!\nusing MLDatasets\nusing PyPlot\nusing ChainRulesCore\nusing Statistics\nusing LinearAlgebra\nusing Images","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"┌ Info: Precompiling PhotoAcoustic [86b14aa7-fcb7-4836-b4c7-056f45a9c77b]\n└ @ Base loading.jl:1662","category":"page"},{"location":"LearnedPrior/#Define-a-neural-network","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Define a neural network","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"struct UNet\n    layers::NamedTuple\nend","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"\"\"\"\nUser Facing API for UNet architecture.\n\"\"\"\nfunction UNet(channels=[32, 64, 128, 256])\n    return UNet((\n        # Encoding\n        conv1=Conv((3, 3), 1 => channels[1], stride=1, bias=false),\n        gnorm1=GroupNorm(channels[1], 4, swish),\n            \n        conv2=Conv((3, 3), channels[1] => channels[2], stride=2, bias=false),\n        gnorm2=GroupNorm(channels[2], 32, swish),\n            \n        conv3=Conv((3, 3), channels[2] => channels[3], stride=2, bias=false),\n        gnorm3=GroupNorm(channels[3], 32, swish),\n            \n        conv4=Conv((3, 3), channels[3] => channels[4], stride=2, bias=false),\n        gnorm4=GroupNorm(channels[4], 32, swish),\n            \n        # Decoding\n        tconv4=ConvTranspose((3, 3), channels[4] => channels[3], stride=2, bias=false),\n        tgnorm4=GroupNorm(channels[3], 32, swish),\n            \n        tconv3=ConvTranspose((3, 3), channels[3] + channels[3] => channels[2], pad=(0, -1, 0, -1), stride=2, bias=false),\n        tgnorm3=GroupNorm(channels[2], 32, swish),\n            \n        tconv2=ConvTranspose((3, 3), channels[2] + channels[2] => channels[1], pad=(0, -1, 0, -1), stride=2, bias=false),\n        tgnorm2=GroupNorm(channels[1], 32, swish),\n            \n        tconv1=ConvTranspose((3, 3), channels[1] + channels[1] => 1, stride=1, bias=false),\n    ))\nend\n\nFlux.@functor UNet","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"expand_dims(x::AbstractVecOrMat, dims::Int=2) = reshape(x, (ntuple(i -> 1, dims)..., size(x)...))\nexpand_dims_rev(x::AbstractVecOrMat, dims::Int=2) = reshape(x,  size(x)...,(ntuple(i -> 1, dims)...))","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"expand_dims_rev (generic function with 2 methods)","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"function (unet::UNet)(x)\n\n    # Encoder\n    h1 = unet.layers.conv1(x)\n    h1 = unet.layers.gnorm1(h1)\n    \n    h2 = unet.layers.conv2(h1)\n    h2 = unet.layers.gnorm2(h2)\n    \n    h3 = unet.layers.conv3(h2)\n    h3 = unet.layers.gnorm3(h3)\n    \n    h4 = unet.layers.conv4(h3)\n    h4 = unet.layers.gnorm4(h4)\n    \n    # Decoder\n    h = unet.layers.tconv4(h4)\n    h = unet.layers.tgnorm4(h)\n    \n    h = unet.layers.tconv3(cat(h, h3; dims=3))\n    h = unet.layers.tgnorm3(h)\n    \n    h = unet.layers.tconv2(cat(h, h2, dims=3))\n    h = unet.layers.tgnorm2(h)\n    \n    h = unet.layers.tconv1(cat(h, h1, dims=3))\nend","category":"page"},{"location":"LearnedPrior/#Define-photoacoustic-simulation","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Define photoacoustic simulation","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"# Set up model structure\nn = (68, 68)   # (x,y,z) or (x,z)\nd = (0.08f0, 0.08f0)\no = (0., 0.)\n\n# Constant water velocity [mm/microsec]\nv = 1.5*ones(Float32,n) \nm = (1f0 ./ v).^2\n\n# Setup model structure\nmodel = Model(n, d, o, m;)\n\n# Set up receiver geometry\nnxrec = 64\nxrec = range(0, stop=d[1]*(n[1]-1), length=nxrec)\nyrec = [0f0]\nzrec = range(0, stop=0, length=nxrec)\n\n# receiver sampling and recording time\ntime = 5.2333 #[microsec] \ndt = calculate_dt(model) / 2    \n\n# Set up receiver structure\nrecGeometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=1)\n\n# Setup operators\nopt = Options(dt_comp=dt)\nF = judiModeling(model; options=opt)\nA = judiPhoto(F, recGeometry;)","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"JUDI forward{Float32} propagator (z * x) -> (src * rec * time)","category":"page"},{"location":"LearnedPrior/#Get-model-x","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Get model x","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"xtrain, ytrain = MNIST.traindata(Float32)\nx = judiInitialState(imresize(xtrain[:,:,1], (n[1], n[2])))","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"judiInitialState{Float32} with 1 sources","category":"page"},{"location":"LearnedPrior/#Make-observed-data","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Make observed data","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"y = A*x\nimshow(y.data[1];aspect=\"auto\")","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"Building forward operator\nOperator `forward` ran in 0.01 s","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"(Image: png)","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"PyObject <matplotlib.image.AxesImage object at 0x2b4df58e0>","category":"page"},{"location":"LearnedPrior/#Add-rrule-for-chainfules-to-know-how-to-differentiate-the-photoacoustic-operator","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Add rrule for chainfules to know how to differentiate the photoacoustic operator","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"function ChainRulesCore.rrule(::typeof(*), A::T, x) where {T<:judiPhoto}\n    y = A*judiInitialState(x)\n    pullback(Δy) = (NoTangent(), NoTangent(), expand_dims_rev((A'*Δy).data[1]))\n    return y, pullback\nend\n","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"function model_loss(A, model, y, z)\n    norm(A*model(z) - y).^2\nend","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"model_loss (generic function with 1 method)","category":"page"},{"location":"LearnedPrior/#Training-Hyperparameters","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Training Hyperparameters","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"device = cpu          # only works on cpu right now\nlr = 5e-3             # learning rate\nepochs = 200           # number of epochs","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"200","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"# initialize UNet model\nunet = UNet() |> device\n\n# initialize input to model. This is not a trainable parameter \nz = randn(Float32, n[1], n[1], 1, 1) |> device\n\n# ADAM optimizer\nopt = ADAM(lr)\n\n# trainable parameters\nps = Flux.params(unet);","category":"page"},{"location":"LearnedPrior/#Training","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Training","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"loss_log = []\nerror_log = []\nprogress = Progress(epochs)\n\nfor epoch = 1:epochs    \n    loss, grad = Flux.withgradient(ps) do\n        model_loss(A, unet, y, z)\n    end\n    Flux.Optimise.update!(opt, ps, grad)\n    \n    append!(loss_log, loss)\n    append!(error_log, norm(unet(z)[:,:,1,1]' - x.data[1][:,:,1,1]')^2)\n    \n    # progress meter\n    next!(progress; showvalues=[(:loss, loss)])\nend","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"┌ Warning: ProgressMeter by default refresh meters with additional information in IJulia via `IJulia.clear_output`, which clears all outputs in the cell. \n│  - To prevent this behaviour, do `ProgressMeter.ijulia_behavior(:append)`. \n│  - To disable this warning message, do `ProgressMeter.ijulia_behavior(:clear)`.\n└ @ ProgressMeter /Users/mathiaslouboutin/.julia/packages/ProgressMeter/sN2xr/src/ProgressMeter.jl:618\n\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:01:21\u001b[39m\n\u001b[34m  loss:  0.011968669\u001b[39m","category":"page"},{"location":"LearnedPrior/#Show-training-log","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Show training log","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"subplot(1,2,1); title(\"Least squares objective\")\nsemilogx(loss_log; );\nsubplot(1,2,2);title(\"Error\")\nsemilogx(error_log; );","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"(Image: png)","category":"page"},{"location":"LearnedPrior/#Plot-our-results","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Plot our results","text":"","category":"section"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"fig = figure(figsize=(8,4))\nsubplot(2,3,1); title(\"Ground truth x\")\nimshow(x.data[1][:,:,1,1]'; vmin=0,vmax = 1); colorbar()\nsubplot(2,3,2); title(\"Deep prior estimation G(z)\")\nimshow(unet(z)[:,:,1,1]'; vmin=0,vmax = 1); colorbar() \nsubplot(2,3,3); title(\"Error\")\nimshow(unet(z)[:,:,1,1]' - x.data[1][:,:,1,1]'; cmap = \"seismic\", vmin=-2, vmax = 2); colorbar()\n\nsubplot(2,3,4); title(\"Observed data y\")\nimshow(y.data[1];aspect=\"auto\"); colorbar()\nsubplot(2,3,5); title(\"Simulated data A*G(z)\")\nimshow((A*judiInitialState(unet(z))).data[1];aspect=\"auto\"); colorbar() \nsubplot(2,3,6); title(\"Data residual\")\nimshow((A*judiInitialState(unet(z))).data[1] - y.data[1];aspect=\"auto\",cmap = \"seismic\", vmin=-0.1, vmax = 0.1);  colorbar() \n\ntight_layout()","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"Operator `forward` ran in 0.01 s\nOperator `forward` ran in 0.01 s","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"(Image: png)","category":"page"},{"location":"LearnedPrior/","page":"Integrating Photoacoustic operations with automatic differention in Flux.","title":"Integrating Photoacoustic operations with automatic differention in Flux.","text":"","category":"page"},{"location":"LSQR/#Solving-photoacoustic-least-squares-with-IterativeSolvers.jl","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"In this tutorial, we will illustrate how to use Photoacoustic.jl in tandem with the solvers in IterativeSolvers.jl to solve inverse problems. Our illustration will be a photoacoustic inverse problem where the observe data has been generated by a photoacoustic operator plus corrupting noise: y = Ax^star + varepsilon where we assume the noise comes from a standard Normal distribution. We want to solve this inverse problem in the least squares sense: hat x = mathrmargmin_x  Ax - y_2^2","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"To use the solvers in IterativeSolver.jl all we need is to define matrix vector products Av and adjoint matrix vector products A^topv. These are both implemented in PhotoAcoustic.jl.","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"using PhotoAcoustic\nusing JUDI\nusing PyPlot\nusing LinearAlgebra","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"┌ Info: Precompiling PhotoAcoustic [86b14aa7-fcb7-4836-b4c7-056f45a9c77b]\n└ @ Base loading.jl:1423","category":"page"},{"location":"LSQR/#Define-photoacoustic-simulation","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Define photoacoustic simulation","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"# Set up model structure\nn = (128, 128)   # (x,y,z) or (x,z)\nd = (0.08f0, 0.08f0)\no = (0., 0.)\n\n# Constant water velocity [mm/microsec]\nv = 1.5*ones(Float32,n) \nm = (1f0 ./ v).^2 # JUDI is parameterized by slowness\n\n# Setup model structure\nmodel = Model(n, d, o, m;)\n\n# Set up receiver geometry (receivers on top of model)\nnxrec = 32\nxrec = range(0, stop=d[1]*(n[1]-1), length=nxrec)\nyrec = [0f0]\nzrec = range(0, stop=0, length=nxrec)\n\n# receiver sampling and recording time\ntime = 10 #[microsec] \ndt = calculate_dt(model) / 2    \n\n# Set up receiver structure\nrecGeometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=1)\n\n# Setup operators\nopt = Options(dt_comp=dt)\nF = judiModeling(model; options=opt)\nA = judiPhoto(F, recGeometry;)","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"JUDI forward{Float32} propagator (z * x) -> (src * rec * time)","category":"page"},{"location":"LSQR/#Make-observed-data","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Make observed data","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"We make observed data by running the linear photoacoustic simulation represented by A and then adding gaussian noise to the data. ","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"using JLD2\nfile_vessels = load(\"$(PhotoAcoustic.PhotoAcoustic_data)/vessels_2d.jld\")\nvessels = file_vessels[\"vessels\"]\nx = judiInitialState(vessels)","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"As ground truth we use a realistic model of a blood vessel derived from lung ct scans. ","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"# Run forward model and add noise\ny = A*x \ny = y + judiVector(recGeometry, 0.05f0*randn(Float32, size(y.data[1])))\n\ndata_extent = (0, nxrec, time,0)\nmodel_extent = (0,(n[1]-1)*d[1],(n[2]-1)*d[2],0)\n\nsubplot(1,2,1); title(L\"Ground truth $x$\")\nimshow(x.data[1]';extent=model_extent);\nxlabel(\"Vertical Position [mm]\");ylabel(\"Lateral Position [mm]\");\nPyPlot.scatter(xrec, zrec;color=\"red\",label=\"Receivers\")\nlegend(loc=\"lower left\")\n\nsubplot(1,2,2); title(L\"Observed data $y=Ax+\\epsilon$\")\nimshow(y.data[1]; cmap=\"seismic\", extent=data_extent, aspect=10,vmax=0.2,vmin=-0.2)\nxlabel(\"Receiver index\");ylabel(\"Time [microseconds]\");\n\n\ntight_layout()","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"Operator `forward` ran in 0.47 s","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"(Image: png)","category":"page"},{"location":"LSQR/#Iteratively-solve-using-different-algorithms:","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Iteratively solve using different algorithms:","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"using IterativeSolvers\n\nx_adj = A'*y\nx_lsqr = 0f0 .* x\n\nmaxiters = 20\n_, history_lsqr = lsqr!(x_lsqr, A, y; maxiter=maxiters, verbose=true, log=true)","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"=== lsqr ===\niter\tresnorm\t\t  anorm\t\t  cnorm\t\t  rnorm\n  1\t1.27e+00\t8.01e-01\t2.86e+00\t7.71e-01\n  2\t1.11e+00\t3.54e-01\t1.02e+00\t6.78e-01\n  3\t9.99e-01\t2.07e-01\t6.01e-01\t6.09e-01\n  4\t9.35e-01\t1.20e-01\t4.36e-01\t5.70e-01\n  5\t8.93e-01\t8.66e-02\t3.48e-01\t5.44e-01\n  6\t8.69e-01\t6.32e-02\t2.89e-01\t5.30e-01\n  7\t8.50e-01\t5.03e-02\t2.46e-01\t5.18e-01\n  8\t8.38e-01\t3.87e-02\t2.14e-01\t5.11e-01\n  9\t8.31e-01\t2.55e-02\t1.90e-01\t5.06e-01\n 10\t8.28e-01\t2.01e-02\t1.70e-01\t5.04e-01\n 11\t8.26e-01\t1.20e-02\t1.54e-01\t5.03e-01\n 12\t8.25e-01\t8.24e-03\t1.41e-01\t5.03e-01\n 13\t8.24e-01\t6.49e-03\t1.31e-01\t5.02e-01\n 14\t8.24e-01\t5.59e-03\t1.21e-01\t5.02e-01\n 15\t8.23e-01\t5.33e-03\t1.12e-01\t5.02e-01\n 16\t8.23e-01\t5.73e-03\t1.02e-01\t5.02e-01\n 17\t8.22e-01\t5.69e-03\t9.44e-02\t5.01e-01\n 18\t8.22e-01\t5.22e-03\t8.75e-02\t5.01e-01\n 19\t8.21e-01\t4.36e-03\t8.19e-02\t5.01e-01\n 20\t8.21e-01\t3.64e-03\t7.73e-02\t5.01e-01\n\n\n\nOperator `adjoint` ran in 0.54 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.41 s\nOperator `adjoint` ran in 0.42 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.61 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.56 s\nOperator `adjoint` ran in 0.49 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.53 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.44 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.41 s\nOperator `adjoint` ran in 0.42 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.42 s\nOperator `adjoint` ran in 0.48 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.40 s\nOperator `adjoint` ran in 0.42 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.46 s\nOperator `adjoint` ran in 1.44 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 1.18 s\nOperator `adjoint` ran in 0.68 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.42 s\nOperator `adjoint` ran in 0.44 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.41 s\nOperator `adjoint` ran in 0.45 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.46 s\nOperator `adjoint` ran in 0.60 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.46 s\nOperator `adjoint` ran in 0.43 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.45 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.41 s\nOperator `adjoint` ran in 0.52 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.45 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.47 s\nOperator `adjoint` ran in 0.42 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.73 s\nOperator `adjoint` ran in 0.46 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.41 s\nOperator `adjoint` ran in 0.41 s\nOperator `Kernel` ran in 0.01 s\nOperator `forward` ran in 0.45 s\nOperator `adjoint` ran in 0.46 s\nOperator `Kernel` ran in 0.01 s\n\n\n\n\n\n(judiInitialState{Float32} with 1 sources, Converged after 20 iterations.)","category":"page"},{"location":"LSQR/#Plotting-convergence-history","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Plotting convergence history","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"plot(history_lsqr[:resnorm];label=\"LSQR\")\nylabel(\"Residual norm\"); xlabel(\"Iteration\"); legend()","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"(Image: png)","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"PyObject <matplotlib.legend.Legend object at 0x15aa35280>","category":"page"},{"location":"LSQR/#Plotting-results","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Plotting results","text":"","category":"section"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"We can visualize our results and interpret that the adjoint solution can resolve the main structures but has wrong amplitudes. A least sqeares method such as LSQR will help bring amplitudes to the correct level. Also observe that both the adjoint and LSQR can resolve structures that are perpendicular to the receiver geometry but miss vertical vessels. This is because the vertical events are in the null space of the operator.  ","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"fig = figure(figsize=(10,7))\nsuptitle(\"Iterative solvers results with $(maxiters) iterations\")\n\nsubplot(2,3,1); title(\"Ground truth\") \nimshow(x.data[1]';extent=model_extent, vmin=0,vmax=1)\nylabel(\"Z Position [mm]\";); xlabel(\"X Position [mm]\"; ); colorbar()\nPyPlot.scatter(xrec, zrec;color=\"red\",label=\"Receivers\")\nlegend(loc=\"lower left\")\n\nsubplot(2,3,2);  title(\"Adjoint solution\")\nimshow(x_adj.data[1]';extent=model_extent)\nylabel(\"Z Position [mm]\";); xlabel(\"X Position [mm]\"; ); colorbar()\n\nsubplot(2,3,3); title(\"LSQR solution\")\nimshow(x_lsqr.data[1]';extent=model_extent, vmin=0,vmax=1)\nylabel(\"Z Position [mm]\";); xlabel(\"X Position [mm]\"; ); colorbar()\n\nsubplot(2,3,5);  title(\"Error adjoint\")\nimshow(x_adj.data[1]' - x.data[1]';cmap=\"seismic\", extent=model_extent, vmin=-2, vmax=2)\nylabel(\"Z Position [mm]\";); xlabel(\"X Position [mm]\"; ); colorbar()\n\nsubplot(2,3,6); title(\"Error LSQR \")\nimshow(x_lsqr.data[1]'- x.data[1]';cmap=\"seismic\",extent=model_extent, vmin=-2, vmax=2)\nylabel(\"Z Position [mm]\";); xlabel(\"X Position [mm]\"; ); colorbar()\n\ntight_layout()","category":"page"},{"location":"LSQR/","page":"Solving photoacoustic least squares with IterativeSolvers.jl","title":"Solving photoacoustic least squares with IterativeSolvers.jl","text":"(Image: png)","category":"page"},{"location":"#PhotoAcoustic.jl-documentation","page":"Home","title":"PhotoAcoustic.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of PhotoAcoustic.jl , a julia package for photoacoustic simulation and inversion integrable with Julia's AD ecosystem via ChainRules.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At the moment, PhotoAcoustic.jl is in developement stage and isn't registered in the Julia General registry. To install PhotoAcoustic.jl run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add/dev https://github.com/slimgroup/PhotoAcoustic.jl","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhotoAcoustic]","category":"page"},{"location":"#PhotoAcoustic.judiInitialState-Union{Tuple{Array{Array{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T<:Number, N}","page":"Home","title":"PhotoAcoustic.judiInitialState","text":"judiInitialState(field)\n\nConstruct an the initial pressure wavefield distributed across space for each experiments. This is a single-time intistate and assumes that the initial time derivative is zero to define the second time step of the second order wave equation. \n\nArguments\n\nsource: a (Vector of) 2D-3D array with spatial distribution of photoacoustic sources\n\n\n\n\n\n","category":"method"},{"location":"#PhotoAcoustic.judiInitialStateProjection-Tuple{Any}","page":"Home","title":"PhotoAcoustic.judiInitialStateProjection","text":"judiInitialStateProjection(model)\n\nConstruct the projection operator that sets the initial state into the wavefield for propagation. This operator is a No-op operation that will propagate a judiInitialState if combined with a JUDI propagator.\n\n\n\n\n\n","category":"method"},{"location":"#PhotoAcoustic.judiPhoto-Union{Tuple{O}, Tuple{D}, Tuple{JUDI.judiPropagator{D, O}, Geometry}} where {D, O}","page":"Home","title":"PhotoAcoustic.judiPhoto","text":"judiPhoto(F::judiPropagator, geometry::Geometry;)\n\nConstructs a photoacoustic linear operator solving the wave equation associated with F.model. The parametrizations currently supported through JUDI are isotropic acoustic (with or without density), acoustic anisotropic (TTI/VTI) and  visco-acoustic.\n\nArguments\n\nF: The base JUDI propagator (judiModeling) geometry: the receiver interpolation (judiProjection) for data measurment\n\n\n\n\n\n","category":"method"}]
}
